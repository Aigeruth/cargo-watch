use std::sync::Arc;
use std::sync::atomic::AtomicInt;
use std::thread::Thread;
use super::{Args, cargo, ignore, notify, timelock};

macro_rules! run_if_set(
  ($flag:ident) => {
    if $flag { cargo::run(stringify!($flag)) }
  }
);

fn compile(t: Arc<AtomicInt>) {
  #![allow(unused_variables)]
  let Args {
    flag_build: mut build,
    flag_doc: doc,
    flag_test: mut test,
    flag_bench: bench,
    flag_help: _, // These three flags are not used. They are generated by docopt
    cmd_watch: _, // because both `cargo-watch` and `cargo watch` must be supported
    cmd_cargo: _ } = Args::docopt().decode().unwrap_or_else(|e| e.exit());
  if !build && !doc &&
     !test && !bench {
    // Default to build & doc
    build = true;
    test = true;
  }
  debug!("Starting a compile");
  run_if_set!(build);
  run_if_set!(doc);
  run_if_set!(test);
  run_if_set!(bench);
  timelock::update(&t);
  debug!("Compile done");
}

fn spawn_compile(t: &Arc<AtomicInt>) {
  info!("Request to spawn a compile");
  // Don't run compiles within less than 2s of each other
  let justnow = timelock::current() - 2;
  let prev = timelock::get(t);
  if prev > justnow {
    info!("Request denied");
  } else {
    timelock::update(t);
    let t2 = t.clone();
    let _ = Thread::spawn(move || { compile(t2); });
  }
}

pub fn handle_event(t: &Arc<AtomicInt>, e: notify::Event) {
  match e.path {
    None => return,
    Some(p) => {
      let name: String = format!("{}", p.display());
      debug!("path: {}", name);
      if ignore::filename(&name) {
        info!("Ignoring change on '{}'", name);
      } else {
        spawn_compile(t);
      }
    }
  }
}
